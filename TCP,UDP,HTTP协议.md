# HTTP协议理论学习
#### 1.http协议概括
HTTP是一个客户端终端（用户）和服务器端（网站）`请求`和`应答`的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。
#### HTTP工作原理


HTTP协议 Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个`请求报文`，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个`相应报文`作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

请求报文格式：
![avatar](https://images2017.cnblogs.com/blog/310916/201712/310916-20171219204642881-662531626.png)

![avatar](https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png)

相应报文格式：
![avatar](https://images2017.cnblogs.com/blog/310916/201712/310916-20171219204643787-1136725771.png)

**工作原理例子：**

1. 在浏览器地址栏键入URL，按下回车之后会经历以下流程；
2. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
3. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
4. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5. 释放 TCP连接;
6.  浏览器将该 html 文本并显示内容; 　

>注意：HTTP1.1连接的时候会进行TCP的三次握手，但是传输数据过程，会根据客户端请求是否要持续连接，来进行数据传输，持续连接的话，服务器端只会确认消息，然后返回消息，两次响应，不会在进行3次握手连接，断开连接是4次TCP分手过程，可见HTTP是无状态协议，但是为了实现期望的保持状态功能，于是引入了`Cookie技术`，有了Cookie就可以管理状态了

如图解释：![avatar](https://images2017.cnblogs.com/blog/310916/201712/310916-20171219204655537-135041907.png)

注意服务器响应是两次，一次是确定收到信息，一次是返回响应报文和数据

**Cookie技术** ：Cookie通过响应报文中的Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再次发往服务器请求时，客户端会自动在请求报文中加入cookie值。服务器端发现客户端发送来得Cookie后，检查从哪个客户端发来的连接请求，然后对比服务器的记录，最后得到状态信息。

#### go标准包实现学习

开启一个http服务，就两个关键点，开启一个server和监听一个tcp地址

```
package main
import ( "log" "net/http" ) 
func sayHello(w http.ResponseWriter, r *http.Request) { 
_, _ = w.Write([]byte("Hello World!")) 
} 
func main() { 
//1.注册一个给定模式的处理器函数到DefaultServeMux
http.HandleFunc("/", sayHello)
//2.设置监听的TCP地址并启动服务 //参数1：TCP地址(IP+Port) 
//参数2：当设置为nil时表示使用DefaultServeMux 
err := http.ListenAndServe("127.0.0.1:8080", nil) 
log.Fatal(err) 
}

```
注意ListenAndServe函数的hander为nil的话，就会默认使用DefaultServeMux作为服务店建立连接，
默认可以自定义，如下
```

package main
import ( 
"log" 
"net/http" 
) 

func sayHello(w http.ResponseWriter, r *http.Request) {
_, _ = w.Write([]byte("Hello World!")) 
}
func main() { 
//1.创建一个ServeMux，将处理器函数注册到serverMux

serveMux := http.NewServeMux()
serveMux.HandleFunc("/", sayHello)
//2.设置监听的TCP地址并启动服务 

err := http.ListenAndServe("127.0.0.1:8080", serveMux) 
log.Fatal(err) 
}
```
server也可以自定义：
```

import ( 
"fmt" 
"net/http"
"time"
) 
type MyHandler struct {}
func (h *MyHandler) ServeHTTP (w http.ResponseWriter, r *http.Request) {
fmt.Fprintln(w, "hello world!")
}
func main() 
{ var handler MyHandler
var server = http.Server{
Addr: ":8080",
Handler: &handler,
ReadTimeout: 2 * time.Second, 
MaxHeaderBytes: 1 << 20, 
} 
var err = server.ListenAndServe()
if err != nil { 
fmt.Printf("http server failed, err: %v\n", err) return } 
}
```

>观看源码学习到了一个函数类型的知识点，只要拥有相同的输入参数和输出（类型和个数相同），就可以进行函数类型的转化，转换后可以使用函数类型定义的方法
>`http. `的handl或者handel函数使用的都是默认的DefaultServeMux


>开启一个http服务 只需要两个参数，一个是tcp端口还有一个是sever，sever是对监听建立一个http连接

# TCP理论学习


`tcp协议`：传输控制协议（TCP，Transmission Control Protocol）是一种**面向连接的、可靠的、基于字节流**的传输层通信协议

#### 基于字节流
tcp的数据传输，应用程序对数据的`发送`和`接收`是没有边界限制的，也就是说对数据的写操作次数和接收端执行的读操作次数之间没有任何数量关系

它只是在3次握手后，会根据一些两端之间的因素来确定，来确定接收和发送缓存队列的大小，和字节流的发送模式。

**所以就会产生2个问题：**

**问题1**
粘包：两个数据包被当做一个数据段发送了，出现粘包的现象。

解决：接收方创建一预处理线程，对接收到的数据包根据数据包格式（如http之间请求行，请求头，和数据之间的换行，回车符格式一样）进行预处理，将粘连的包分开。


**问题2**
TCP 提供了字节流服务，而通信双方不保留记录的边界，应用程序如何提供自定义的记录标识？


特殊字符间隔：应用程序使用自己约定的规则来表示消息的边界，比如有一些使用回车+换行（"\r\n"），比如 http协议一样。

### 面向连接

指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能**建立可靠的连接**。建立连接，是为数据的可靠传输打下了基础

### 三次握手

直接上图理解：
![avtar](https://img2018.cnblogs.com/blog/1351999/201905/1351999-20190530170825013-725479705.png)

流程解析：


1. 最开始两段TCP都是处于CLOSED，A主动打开连接，B被动打开连接　
2. B的TCP服务器进程创建传输控制模块TCB，准备接收客户端的请求，处于LISTEN　
3. A也创建TCB后　　　
    *  一次握手：A向B发送连接请求报文段，同步位SYN=1，选择一个初始序号seq=x。SYN报文段不能携带数据，但是消耗一个序号，然后处于SYN-SENT状态　　　

    * 二次握手：B收到报文段，如果同意，发送确认报文段。SYN=ACK=1，确认号ack=x+1，为自己选择初始序号seq=y。这个报文段也不能携带数据，也消耗一个序号，处于SYN-RCVD　　　　

    *  三次握手：client收到Server的确认报文段，还要给Server返回确认报文段。ACK=1,ack=y+1,seq=x+1


为什么不是两次握手？　　

如果client发送的报文段没有丢失，而是在某个网络节点被滞留，然后过了一段时间传递到server，这时已经是一段过期的报文段，server同意建立连接，而client现在并没有发送请求，不会发送请求，这样就会**浪费server的资源**，所以采用三次握手就可以避免这种情况

### 可靠传输

1. 校验和：
如果收到一个校验和有差错的报文，TCP 会直接丢弃不回复，等待发送端重新发送该报文TCP 包的首部中用两个字节来表示校验和

1. 包的序列号：对于可靠传输，判断丢包，误码靠的是TCP的段编号（序号seq number）以及确认号，如果接收端实体已经收到会＋1， TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；
2. 超时重传：如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传，然后继续等待更长时间，如果还没有收到 ACK 确认再重传，经过多次重传还不行后，TCP 会放弃这个网络包
3. 流量控制、拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞


### 报文

![avatar](https://img2018.cnblogs.com/blog/1351999/201905/1351999-20190529155952732-1690622110.png)


1. 　源端口、目的端口：占用2byte，实现分用功能（TCP通过端口把请求分发到应用层不同的应用程序）　
2. 　序号：占用4byte，序号增加到最大，就会重新回到0，也就是使用的mod(取余)2^32运算　　TCP面向字节流的，同一个TCP连接中传送的字节流中每个字节都是按照顺序编号，整个要传送的字节流的初始序号在连接建立的时候设置，首部中的序号指的是本报文段所发送的数据的第一个字节的序号。　
3. 　确认号ack：占用4byte，指的是希望收到对方的下一个报文段的首个字节的序号　
4. 　数据偏移：占用4bit，指的是TCP报文段首部的长度，因为选项的长度不确定，所以数据偏移的存在是很有必要的，数据偏移的最大长度60byte，所以选项的长度不超过40byte　
5. 　保留：占6bit　
6. 　紧急URG(URGent)：当URG=1时，紧急指针字段有效，应用程序告诉TCP发送端有紧急数据需要发送，于是TCP把紧急数据插入到本报文段数据的最前面，后面的数据仍然是普通数据，需要和紧急指针配合使用　
7. 　确认ACK：ACK=1生效，在连接建立之后发送的所有报文段ACK都要置为1　
8. 　推送PSH：发送方把PSH置为1，并立即创建一个报文段发送出去，接收方收到PSH=1的报文段，就尽快的交付给应用程序，不需要等到整个接收缓存填满之后再向上交付。但是很少使用　
9. 　复位RST：当RST=1时，表明TCP连接出现严重差错，必须释放连接，然后重新建立连接，还可以用来拒绝一个非法的报文段或者拒绝打开一个非法连接。RST也称为重置位或重建位　
10. 　同步SYN：在连接建立时同步序号。　
11. 　终止FIN：用来释放一个连接　
12. 窗口：占用2byte，指的是发送方的接收窗口，而不是发送窗口。
 窗口值的作用就是：从本报文段的首部确认号开始，接收方允许发送报文的数据量，之所以有这个限制，这是因此接收方的数据缓存是有限的。窗口值作为接收方让发送方设置其发送窗口的依据。

1. 检验和：占用2byte，通过加上伪首部，检验首部和数据。紧急指针：占用2byte，只有URG=1才有效，指的是紧急数据的大小，紧急数据末尾在报文段的位置，窗口为0的时候也可以发送紧急数据。
2. 选项：长度可变，最大40byte　
3. cwnd：发送端窗口(congestion window)　
4.  rwnd：接收端窗口(receiver window)　最大报文段长度MSS：实际指的是TCP报文段中数据字段的最大长度，MSS尽量大一点，只要在网络层传输不需要分片就行

### 滑动窗口


TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。

为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。

![50a077b683ddfef3d5fcae233f5b4a52.png](en-resource://database/910:1)

![avatar](https://img2018.cnblogs.com/blog/1351999/201905/1351999-20190530202914278-414257483.png)



**窗口控制中的重发控制**

第一种情况：
确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的：
是通过下一次应答进行确认判断的。

第二种情况：

某个报文段丢失

![e2500d9923bb5490d25271d6b1ccf082.png](en-resource://database/912:1)


发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为**高速重发控制**。

### 四次挥手

![avatar](https://img2018.cnblogs.com/blog/1351999/201905/1351999-20190529171926706-286912785.png)


* 第一次挥手：　

TCP发送一个FIN(结束，即使不携带数据，也要消耗一个序号)，用来关闭客户端到服务端的连接。此时A处于FIN-WAIT-1状态。u等于前面已发送过的数据的最后一个字节的序号+1。然后B进入CLOSE-WAIT状态，TCP服务器通知应用程序，从A到B的连接就释放了，此时TCP连接处于HALF-CLOSE状态，但是B到A的连接没有关闭（Client是A，Server是B），这时如果B发送报文，A还是要接收的

* 第二次挥手：

B返回一个ACK(确认位)，ack=u+1(FIN消耗一个序号)。v等于B之前已发送的数据的最后一个字节的序号+1。等待B发送连接释放报文段。　　A收到之后处于FIN-WAIT-2

* 第三次挥手：

　如果B不再向A发送数据，应用程序通知B释放连接，发送一个FIN=1,seq=w,ack=u+1到A，seq为w（因为HALF-CLOSE状态的B可能有发送一些数据了），Server关闭Client的连接，B处于LAST-ACK。
* 第四次挥手：　　

A发送报文段到B，ACK=1,seq=u+1,ack=w+1。这时A处于TIME-WAIT状态。这时TCP连接还没有释放，经过2MSL(时间等待计时器设置的2MSL，MSL是最长报文段寿命，建议设置2minute)后，A才进入CLOSED。之后才能创建新的连接。当A撤销TCB之后，结束这次TCP连接

**为什么需要经过2MSL才进入CLOSED?**
原因：　
1、为了保证A发送的最后一个ACK报文段能够达到B　
2、防止已经失效的连接请求报文段出现在本连接中，这样可以使这次连接中产生的所有报文段从网络中消失


**为什么是4次挥手呢，ACK和FIN不同时发送给client？**
因为在关闭连接时，发送FIN给对方，只是表明我不想发送数据，

但是我还是可以接收数据的，但是对方是否关闭发送数据通道，需要上层应用层来决定，因此，ACK和FIN都是分开发送的

# UDP协议

Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种**无需建立连接**就可以发送**封装的 IP 数据报**的方法

它是 无连接的、无可靠的、基于数据报文的传输层协议：


类似发短信。不管对方是否开机，发送方都会显示发送成功。

**应用场景** 直播

**特性：**
* 无连接
知道对方的IP和端口号直接进行传输, 不需要建立连接。
* 不可靠 
没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方UDP协议层也不会给应用层返回任何错误信息。
* 面向数据报文
不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。数据接收不够灵活，但是能够明确区分两个数据包，避免粘包问题。

* 有单播，多播，广播的功能
UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。
